# 图形绘制技术Project (Option 1)

*151220129* 吴政亿

*151220114* 王宇鑫

## 项目背景

### 三维图形绘制的基本概念

**三维计算机图形**（英语：*3D computer graphics*）是[电子计算机](https://zh.wikipedia.org/wiki/電子計算機)和特殊三维[软件](https://zh.wikipedia.org/wiki/软件)帮助下创造的作品。一般来讲，该术语可指代创造这些图形的过程，或者三维计算机图形技术的研究领域，及其相关技术。

三维计算机图形和[二维计算机图形](https://zh.wikipedia.org/wiki/二维计算机图形)的不同之处在于计算机内存储存了几何数据的三维表示，用于计算和绘制最终的二维图像。

创建三维计算机图形的过程可以顺序分为三个基本阶段：

- [建模](https://zh.wikipedia.org/wiki/建模)
- 场景布局和动画
- 绘制

建模过程可能也包括编辑物体表面或材料性质（例如，颜色，荧光度，漫射和镜面反射分量—经常被叫做粗糙度和光洁度，反射特性，透明度或不透明度，或者折射指数），增加纹理，凹凸映射和其它特征。

把物体的表示（例如[球面](https://zh.wikipedia.org/wiki/球面)的中[点](https://zh.wikipedia.org/wiki/点)[坐标](https://zh.wikipedia.org/wiki/坐标)和它的[表面](https://zh.wikipedia.org/wiki/表面)上的一个点所表示的球面），转换到一个（球面的）多边形表示的过程，称为*剖分（tesselation）*。该步骤用于基于多边形的绘制，其中对象从象球面，[圆锥面](https://zh.wikipedia.org/w/index.php?title=圆锥面&action=edit&redlink=1)等等这样的抽象的表示（“体素”），分解成为所谓“网格”，它是互相连接的三角形的网络。

三角网格（而不是[正方形](https://zh.wikipedia.org/wiki/正方形)等形状）比较流行，因为它们易于采用[扫描线绘制](https://zh.wikipedia.org/w/index.php?title=扫描线绘制&action=edit&redlink=1)进行绘制。

多边形表示不是所有绘制技术都必须的，而在这些情况下，从抽象表示到绘制出的场景的转换不包括剖分步骤。

在渲染成[图象](https://zh.wikipedia.org/wiki/图象)之前，模型必须放置在一个[场景](https://zh.wikipedia.org/w/index.php?title=场景&action=edit&redlink=1)中。这定义了模型的位置和大小。

场景设置涉及安排一个场景内的虚拟物体，灯光，摄像机和其他实体，它将被用于制作一幅静态画面或一段动画。

照明是场景布置中一个重要的方面。就象在实际场景布置的时候一样，光照是最终作品的审美和视觉质量的关键因素之一。因而，它是一项很难掌握的艺术。光照因素可以对一个场景的氛围和情绪反映作出重大贡献，这是为摄影师和舞台照明师所熟悉的事实。

[渲染](https://zh.wikipedia.org/wiki/渲染)是从准备的场景创建实际的二维景象或动画的最后阶段。这可以和现实世界中在布景完成后的照相或摄制场景的过程相比。

用于诸如游戏或模拟程序这样的交互式媒体的渲染需要实时计算和显示，速度约为20到120帧每秒。非交互式媒体（譬如录象或电影），渲染的慢得多。非实时渲染使得有限的计算能力得以放大以获得高质量的画面。复杂场景的单帧的渲染速度可能从几秒到一个小时或者更多。渲染完成的帧存贮在硬盘，然后可能转录到其它媒介，例如电影胶卷或者光盘。然后这些帧以高帧率播放，通常为24，25，或30帧每秒，以达成运动的假象。

最后的作品经常会需要达到真实感图形质量，要达到这个目的，很多不同和专门的渲染技术被发展出来。这些技术的范围包括相当非真实感的[线框模型](https://zh.wikipedia.org/wiki/线框模型)渲染技术，到基于多边形的渲染，到更高级的技术，例如：[扫描线渲染](https://zh.wikipedia.org/wiki/扫描线渲染)、[光线跟踪](https://zh.wikipedia.org/wiki/光线跟踪)或者[辐射着色](https://zh.wikipedia.org/wiki/辐射着色)。

渲染软件可以模拟例如[镜头光晕](https://zh.wikipedia.org/w/index.php?title=镜头光晕&action=edit&redlink=1)、[景深](https://zh.wikipedia.org/wiki/景深)或者[运动模糊](https://zh.wikipedia.org/wiki/运动模糊)这样的视觉效果。这些技术试图模拟镜头和人眼的光学特性所造成的视觉现象。这些技术可以增加场景的真实程度，虽然该效果可能只是镜头的人造模拟现象。

为模拟其他自然发生的效应的各种技术被发展出来，例如光和不同形式的物质的相互作用。这些技术的例子包括[粒子系统](https://zh.wikipedia.org/wiki/粒子系统)（它可以模拟雨，烟，或者火），[体采样](https://zh.wikipedia.org/w/index.php?title=体采样&action=edit&redlink=1)（用于模拟雾，尘或者其它空间大气效果），[焦散效果](https://zh.wikipedia.org/w/index.php?title=焦散效果&action=edit&redlink=1)（用于模拟光被不均匀折射性质的表面所聚焦的现象，例如游泳池底部的光的涟漪），还有[次表面散射](https://zh.wikipedia.org/wiki/次表面散射)（subsurface scattering，用于模拟光在人的皮肤这样的实体对象内部反射的现象）。

现代三维计算机图形严重的依赖于一个简化的反射模型称为*Phong反射模型*，它和[Phong明暗图](https://zh.wikipedia.org/w/index.php?title=Phong明暗图&action=edit&redlink=1)是完全不同的主题，不能混淆二者。

### 几何模型

#### 球（Shpere）

![sphere](sphere.png)

| 变量名           | 意义                                                         |
| ---------------- | ------------------------------------------------------------ |
| glm::vec3 center | 球的中心点在世界坐标系的三维坐标                             |
| float radius     | 球的半径                                                     |
| int m            | 在z轴上的切片步数，越大则球在z轴越光滑，但是会增加绘制复杂度 |
| int n            | 在x轴和y轴上的切片步数，越大则球在x轴和y轴越光滑，但是会增加绘制复杂度 |



| 函数名    | 功能                                                         |
| --------- | ------------------------------------------------------------ |
| draw      | 根据参数center、radius、m、n绘制球体                         |
| intersect | 根据传入参数光线与球求交点，返回交点的位置                   |
| apply     | 根据传入的四维矩阵，对球进行旋转、平移、放缩变换             |
| normal    | 根据传入的点的坐标（已知点在物体表面），返回该点所在的法向量 |
| inside    | 根据传入的点的坐标，判断点是否在球内                         |

#### 立方体（Cube）

![cube](cube.png)

| 变量名                           | 意义                                              |
| -------------------------------- | ------------------------------------------------- |
| glm::vec3 axis_x, axis_y, axis_z | 球的中心点在世界坐标系的三维坐标                  |
| glm::vec3 extend                 | 球的半径                                          |
| glm::vec3 center                 | 立方体的中心点在世界坐标系的三维坐标              |
| glm::vec3 vertex[8]              | 立方体的八个顶点在立方体坐标系的三维坐标          |
| glm::mat4 T                      | 坐标变换矩阵，世界坐标系坐标*T = 立方体坐标系坐标 |



| 函数名         | 功能                                                         |
| -------------- | ------------------------------------------------------------ |
| draw           | 根据参数vertex[8]绘制球体                                    |
| intersect      | 根据传入参数光线与立方体求交点，返回交点的位置               |
| apply          | 根据传入的四维矩阵，对立方体进行旋转、平移、放缩变换         |
| normal         | 根据传入的点的坐标（已知点在物体表面），返回该点所在的法向量 |
| inside         | 根据传入的点的坐标，判断点是否在球内                         |
| init_vertex    | 根据参数axis_x,axis_y,axis_z,extend,center初始化vertex[8]    |
| init_T         | 根据参数vertex[8]计算坐标变换矩阵                            |
| plane          | 根据平面上一点以及平面的法向量，得到平面方程，并与传入参数射线求交点 |
| point_in_plane | 传入四个点abcd（构成一个矩形）和一个点x，判断点是否在围成点矩形中 |

#### 光线（Ray）

![ray](ray.png)

| 变量名                    | 意义                                                         |
| ------------------------- | ------------------------------------------------------------ |
| glm::vec3 rgb             | 球的中心点在世界坐标系的三维坐标                             |
| float weight              | 光线的权重                                                   |
| unsigned time;            | 在z轴上的切片步数，越大则球在z轴越光滑，但是会增加绘制复杂度。 |
| std::vector<ray *> childs | 在x轴和y轴上的切片步数，越大则球在x轴和y轴越光滑，但是会增加绘制复杂度 |



| 函数名    | 功能                                 |
| --------- | ------------------------------------ |
| direction | 根据参数center、radius、m、n绘制球体 |
| is_inside | 判断光线是否在物体内部               |

### 光源模型

### 相机模型

#### 小孔成像



![hole](hole.bmp)

小孔成像模型是相机成像采用最多的模型。在此模型下，物体的空间坐标和图像坐标之间是线性的关系，因而对相机参数的求解就归结到求解线性方程组上。四个坐标系的关系图如下图所示，其中 M 为三维空间点，m 为 M 在图像平面投影成的像点。![hole2](hole2.png)

#### 薄透镜

<!--插图-->

### 材质模型

### 对比分析四种常用光照算法

#### 光线投射

![raycasting](raycasting.jpg)

光线投射（Ray Casting），作为光线追踪算法中的第一步，其理念起源于1968年，由Arthur Appel在一篇名为《 Some techniques for shading machine rendering of solids》的文章中提出。其具体思路是从每一个像素射出一条射线，然后找到最接近的物体挡住射线的路径，而视平面上每个像素的颜色取决于从可见光表面产生的亮度。

#### 光线跟踪

![raytracing](raytracing.jpg)

1979年，Turner Whitted在光线投射的基础上，加入光与物体表面的交互，让光线在物体表面沿着反射，折射以及散射方式上继续传播，直到与光源相交。这一方法后来也被称为经典光线跟踪方法、递归式光线追踪（Recursive Ray Tracing）方法，或 Whitted-style 光线跟踪方法。

光线追踪方法主要思想是从视点向成像平面上的像素发射光线，找到与该光线相交的最近物体的交点，如果该点处的表面是散射面，则计算光源直接照射该点产生的颜色；如果该点处表面是镜面或折射面，则继续向反射或折射方向跟踪另一条光线，如此递归下去，直到光线逃逸出场景或达到设定的最大递归深度。

光线追踪（Ray tracing）是三维计算机图形学中的特殊渲染算法，跟踪从眼睛发出的光线而不是光源发出的光线，通过这样一项技术生成编排好的场景的数学模型显现出来。这样得到的结果类似于光线投射与扫描线渲染方法的结果，但是这种方法有更好的光学效果，例如对于反射与折射有更准确的模拟效果，并且效率非常高，所以当追求高质量的效果时经常使用这种方法。

光线跟踪的一个最大的缺点就是性能，需要的计算量非常巨大，以至于目前的硬件很难满足实时光线追踪的需求。传统的光栅图形学中的算法，利用了数据的一致性从而在像素之间共享计算，而光线跟踪通常是将每条光线当作独立的光线，每次都要重新计算。但是，这种独立的做法也有一些其它的优点，例如可以使用更多的光线以抗混叠现象，并且在需要的时候可以提高图像质量。尽管它正确地处理了相互反射的现象以及折射等光学效果，但是传统的光线跟踪并不一定是真实效果图像，只有在非常近似或者完全实现渲染方程的时候才能实现真正的真实效果图像。由于渲染方程描述了每个光束的物理效果，所以实现渲染方程可以得到真正的真实效果，但是，考虑到所需要的计算资源，这通常是无法实现的。于是，所有可以实现的渲染模型都必须是渲染方程的近似，而光线跟踪就不一定是最为可行的方法。包括光子映射在内的一些方法，都是依据光线跟踪实现一部分算法，但是可以得到更好的效果。

#### 分布式光线跟踪

Cook于1984年引入蒙特卡洛方法（Monte Carlo method）到光线跟踪领域，将经典的光线跟踪方法扩展为分布式光线跟踪算法（Distributed Ray Tracing），又称为随机光线追踪（stochasticray tracing），可以模拟更多的效果，如金属光泽、软阴影、景深（ Depthof Field）、运动模糊等等。

#### 路径跟踪

![pathtracing](/Users/wzy/Documents/RayTracingDemo/report/pathtracing.jpg)

Kajiya于1986年提出了路径追踪算法的理念，开创了基于蒙特卡洛的全局光照这一领域。根据渲染方程， Kajiya 提出的路径追踪方法是第一个无偏（Unbiased）的渲染方法。路径追踪的基本思想是从视点发出一条光线，光线与物体表面相交时根据表面的材质属性继续采样一个方向，发出另一条光线，如此迭代，直到光线打到光源上（或逃逸出场景），然后用蒙特卡洛的方法，计算其贡献，作为像素的颜色值。

简单来说，路径追踪 = 光线追踪+ 蒙特卡洛方法。

### 实验目的

探究以物理为基础的真实绘制---主要是光线的能量追踪，所带来的优势和劣势。

## 系统分析与设计

### 模块分解图

类图：

![img](class_diagram.jpg)

### 光照算法



```python
rays = camera.rays() # 从相机模型中获取生成光线列表
for ray in rays:
    intersection = ray.intersect(models) # 跟场景中的物体相交，找到交点以及表面信息（如法向量、散射类型、参数）
    if intersection.stop():
        ray.update() # 如果光线没有与任何物体相交，或者散射次数达到设定上限，就会停止生成次生光线，并更新光线能量
    else:
        new = BRDF(intersection) # 根据表面信息，生成次生光线，可能会需要采样一定数量的光线（比如漫反射、phone高光反射）
        rays.append(new) # 这些光线之后也要进行相关操作
```

我们设计的系统原生支持蒙特卡洛积分方法，所有的光线都带有权值。在求交的时候，不同的类别会导致光线不同的行为。每个类别都会根据一个入射光light，一个法向量norm，包括入射点in_point，甚至出射点out_point，生成数量不等的（根据采样数量设置）次生光线。

## 系统实现

### 开发与运行环境

1. QT5.12.2
1. opengl
1. c++17
1. win/mac

### 重要模块/算法实现细节

#### renderer

渲染主要流程。

渲染主要流程。
首先，在设计上，我们的程序是双线程的，OpenGL以及qt的UI所在的线程为主要线程，其主要负责绘制。

而renderer是另一个任务的线程，它不是平时所说的"渲染"，而是负责管理光线、图形交互的主类。

所以它就是整个路径追踪算法的主要逻辑实现类。

该线程理论上不允许同时运行多个光线渲染任务，所以它有一个互斥锁，它限制任何的重复调用。

该类理论上不需要复制、转移构造，所以上述两个构造函数声明为delete。

而实现逻辑的主要函数在render(scene &scn)与BRDF中。

##### render(scene &scn)

除了上述光照算法伪代码外，这里多写一些细节：

```c++
shared_ptr<camera> cmr(?); // 动态的处理不同的相机类型，只考虑他们的接口
vector<ray> rays = cmr->generate(); // 接口为生成一组光线的方法
vector<ray>::iterator it = rays.begin();
while ( it != rays.end() ) {
    ray r = *it++; // 每次处理第一根光线，而生成的光线放在最后，并且会保持光线之间的父子关系，已经处理过的光线也不会删除，保证更新能量的时候能正确贡献每一根光线的能量
   intersection i = min( r.intersect(models) ); // 还是计算相交的信息
    if (i.stop()) {
        ray.stop(); // 更新光线本身的能量，以及其所有父代的能量
    }
    else {
        rays.append( BRDF(intersection) ); // 依旧是加入所有次生光线
    }
}
```

##### BRDF(intersection i)

这个方法着重处理不同的分布所产生次生光线的不同。

```c++
if (s.is_light())
    return s.power(); // 光源直接返回该光源的能量
shared_ptr<ray_distribution> rd; // 而不同的分布由一个静态工厂选择
switch(s.distribution_type) {
case phone: rd = phone_distribution(...); break;
case mirror: rd = mirror_distribution(...); break;
case diffuse: rd = diffuse_distribution(...); break;
}
return rd->intersection();
```

#### camera

相机光线生成类似上述次生光线生成，都是根据不同的信息产生不同的序列。

小孔相机：

```c++
vec3 start = position + direction * factor; // 从前方的一个平面开始，生成一系列等间距光线
for (int i = 0; i < width; i++) {
    for (int j = 0; j < height; j++) {
        p = position(start, i, j); // 计算位置和方向
        ...
    }
}
```

薄透镜：未实现

#### ray_distribution

次生光线生成，有几种不同形式，总之都需要实现一个接口

```c++
vector<ray> random(int num) const;
```

##### mirror_distribution

有两个参数，决定反射与折射的比例（reflection_rate，refraction_rate；标准化后的），还有一个是折射率$\eta$。

反射只需要计算：
$$
\vec{d} + 2\vec{n}
$$
返回一根这个方向的，权值为reflection_rate的光线即可。

折射多了一点参数，但总之还是一个公式：
$$
\left(\eta\vec{n}\vec{l} - \sqrt{1 - \eta^2(1 - \frac{\vec{n}^2}{\vec{l}^2})}\right)\vec{n} - \eta\vec{l}
$$
最终返回一根这个方向的，权值为refraction_rate的光线即可。

镜面反射和折射不受采样数目num的影响，必然生成两根光线（只要权值不为0）。

##### diffuse_distribution

这个分布比较特殊，它是一个比较随机的分布（如果不考虑光源的分布的话）。

只需要产生一个随机方向，将其约束到半球（正向），然后旋转到法向方向即可。

我采用的是uniform_distribution(mt19937)生成均方分布。

##### phone_distribution

phone高光类似diffuse_distribution，也是需要采样的分布，最大的区别是，phone高光有一个镜面反射方向的采样光线，以及服从一定分布的随机采样。

在这里我采用的是高斯分布生成二维的高斯采样：

```c++
normal_distribution(mt19937);
```

如果出现超过约束范围的值，就重新计算。（限定最多3次），但因为高斯分布$2\sigma$能保证95%的命中率，所以重复三次还在外部的概率极低（0.0125%）。如果还在范围外，我就会把它约束到边界（normalize() * limit）。

#### serilization

序列化。

考虑过几种实现方法：

1. 数据库
2. json文件
3. 序列化

其中数据库不擅长多态类型的（shape）数据，比较常用于需要经常查询的情况，所以没有考虑使用。

json文件方便、可配置、可读性高、可扩展性高，但是动态类型实现相对比较复杂。

直接对内存进行序列化，是一种实现高效、运行速度快、空间占用低的方式。不会有多余的处理，并且非常稳定（每一个内存都会被copy）。但比起json，它没有可读性，并且及其容易受到模型的变化影响，每次更新模型内容都需要重新保存。

最终我选择了使用序列化来保存整个模型。

## 效果演示

> 对演示图截图并分析光纤能量分布情况。通过调整几何、光源、相机以及材质等参数，记录场景中光线的分布变化情况，与理论分析相对应，总结规律。

<!--
展示：

1. 镜面折射之后漫反射，其中一部分碰到光源
2. 镜面反射后phone高光反射，碰到光源
   -->

## 实现内容与分工

<!--我们实现了什么东西，我们每个人都在做什么东西-->

## 总结与展望

> 碰到的问题与解决方案
>
> 未解决的问题给出可能的解决

## 参考资料

1. [https://zh.wikipedia.org/wiki/%E4%B8%89%E7%BB%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2](https://zh.wikipedia.org/wiki/三维计算机图形)

2. [http://www.sohu.com/a/228632244_468740](http://www.sohu.com/a/228632244_468740)
3. 